from __future__ import annotations
# from importlib import import_module
from typing import Any, Optional, Self
from indiek.mockdb import items as default_driver


IKID = 'iKiD'

class NestedNoteLoop(Exception): pass
class AddContentToPointerNote(Exception): pass
class DeadPointerNoteSave(Exception): pass


class Nucleus:
    """Nuclear item."""

    def __init__(self, ikid: Optional[int] = None, driver: Any = default_driver):
        self.ikid = ikid
        # TODO: ok to override class var like this with every instance?
        self.__class__.backend = driver

    @classmethod
    def load(cls, ikid) -> Item:
        """Create Core Item from backend using ikid."""
        # breakpoint()
        return cls.from_db(getattr(cls.backend, cls.__name__).load(ikid))

    @property
    def exists_in_db(self):
        """Check whether item was ever saved. Doesn't query the DB at all. """
        return self.ikid is not None
    
    def save(self) -> int:
        """Save to backend.
        
        This method delegates the save operation to the backend.
        If ikid is None in self, it will get set to new value
        generated by backend.
        """
        self.ikid = self._to_db().save()
        return self.ikid
    
    def delete(self) -> None:
        self._to_db().delete()
        self.ikid = None

    def _to_db(self):
        """Must return a saveable DB backend object."""
        raise NotImplementedError
    
    @classmethod
    def from_db(cls, db_item):
        raise NotImplementedError()


def str2note(string_or_note: str | Note) -> Note:
    if isinstance(string_or_note, Note):
        return string_or_note
    note = Note()
    note.add_content(string_or_note)
    return note


class Item(Nucleus):
    """Generic Item in IndieK core.

    A note on unique id ikid. The assignments and checks for uniqueness are 
    usually handled by the backend driver. Therefore, usual flow for new Item
    creation is the following:
    1. Item instance is created in indiek-core without ikid attr set to None.
    2. When the `save` method is called, the backend generates a unique ikid and
       it gets saved as attr to current indiek-core Item instance.
    3. If `save` is called while `ikid` is already set, then the backend will 
       take that value as is, potentially overriding any pre-existing items in DB. 

    Attributes:
        ikid (int): a unique identifier.
        name (str): a human-friendly short identifier.
        content (str): some string with data the Item is meant to hold or reference.
        backend (Any): backend port for I/O operations with DB
    """

    _attr_defs = ['ikid', 'content', 'name']
    
    def __init__(self, *, name: str | Note = '', content: str | Note = '', ikid: Optional[int] = None, driver: Any = default_driver):
        super().__init__(ikid, driver)
        self.name = str2note(name)
        self.content = str2note(content)

    def __repr__(self):
        ikid = self.ikid
        name = self.name
        content_hash = hash(self.content)
        driver = self.backend
        return f"module: {__name__}; class:{self.__class__.__name__}; {ikid=}; {name=}; {content_hash=}; {driver=}"
    
    def __hash__(self):
        # TODO: not sure this __hash__ method follows best practices
        return hash((self.ikid, self.name, self.content, self.__class__.__name__))

    def __str__(self):
        return f"Core {self.__class__.__name__} with ID {self.ikid} and name {self.name}"

    def __eq__(self, other) -> bool:
        return (self.ikid == other.ikid
                and self.name == other.name
                and self.content == other.content
                and type(other) == type(self))

    def _to_db(self):
        """Export core Item to DB Item instance."""
        as_dict = self.to_dict()
        try:
            return getattr(self.backend, self.__class__.__name__)(**as_dict)
        except AttributeError:
            return self.backend.Item(**as_dict)

    @classmethod
    def from_db(cls, db_item: default_driver.Item) -> Item:
        """Instantiate core Item off of backend Item."""
        return cls(**db_item.to_dict())
    
    def to_dict(self):
        """Export core Item content to dict."""
        return {a: getattr(self, a) for a in self._attr_defs}
    

# TODO: automate class creation below
class Definition(Item): pass
class Theorem(Item): pass
class Proof(Item): pass
class Question(Item): pass
CORE_ITEM_TYPES = [Definition, Theorem, Proof, Question]

        
class Note(Nucleus):
    """Generic note.

    A note contains a sequence of entries, each entry
    being either a string literal or a Note itself.

    Notes are meant to act as Wikis in IndieK.
    """

    def __init__(self, *, ikid: Optional[int] = None, driver: Any = default_driver):
        super().__init__(ikid, driver)
        self.content = []
        self.mentions = set()  # flat mentions of objects
        self.children = set()  # flat descendence of notes
        # TODO: add a content_type attr?
        # self._depth = 1
    
    @classmethod
    def from_db(cls, db_item):
        # backend = import_module(db_item.__module__)
        note = cls(ikid=db_item.ikid)
        note.mentions = db_item.mentions
        note.children = db_item.children
        content = []
        for entry in db_item.flat_content:
            is_note, child_ikid = db_item.is_note(entry)
            if is_note:
                child = db_item.__class__.load(child_ikid)
                content.append(cls.from_db(child))
            else:
                content.append(entry)
        note.content = content
        return note
            

    @property
    def depth(self):
        note_children = [e for e in self.content if isinstance(e, Note)]
        if note_children:
            return 1 + max(c.depth for c in note_children)
        return 1

    def add_content(self, content: Self | str) -> None:
        if not isinstance(content, str):
            if self.ikid in content.children:
                raise NestedNoteLoop(f"{self} already a child of {content}")
            self.update_mentions(content)
            self.update_children(content)
            # self._depth += content.depth
        self.content.append(content)

    def __hash__(self):
        return hash(tuple([tuple(map(hash, self.content)), self.ikid]))

    def __eq__(self, other):
        return hash(self) == hash(other)
    
    def __str__(self) -> str:
        """Resolves content into str.

        Returns:
            str: string representation.

        Raises:
            RecursionError: if loops are present (a contains b contains a)
        """
        # TODO: store the start-end chars positions of each content entry
        return ' '.join(map(str, self.content))

    def _to_db(self):
        return self.backend.Note.from_core(self)

    def update_mentions(self, content):
        self.mentions.update(content.mentions)

    def update_children(self, content):
        self.children.update(content.children)
        self.children.update({content.ikid})


class PointerNote(Note):
    """Note designed to solely refer to an IndieK item or to another note.

    This kind of notes doesn't allow for content addition.

    Args:
        Note (_type_): _description_
    """

    def __init__(self, reference: Nucleus | int, *, ikid: Optional[int] = None, driver: Any = default_driver):
        if isinstance(reference, Nucleus):
            # remember line below is a shallow check
            assert reference.exists_in_db, "Cannot reference unsaved item or note."
            super().__init__(ikid=ikid, driver=driver)
            self.content = [IKID + str(reference.ikid)]
            self.mentions = {reference.ikid}
        else:
            ref_id = reference
            # emulate shallow check below
            assert isinstance(ref_id, int), "Reference ikid is not an int."
            super().__init__(ikid=ikid, driver=driver)
            self.content = [IKID + str(ref_id)]
            self.mentions = {ref_id}
        # breakpoint()

    def add_content(self) -> None:
        raise NotImplementedError(f"{self.__class__} doesn't allow content addition.")
    
    @classmethod
    def from_db(cls, db_item):
        # backend = import_module(db_item.__module__)
        ref_id = next(iter(db_item.mentions))
        note = cls(ref_id, ikid=db_item.ikid)
        return note
